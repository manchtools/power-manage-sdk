// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.30.2
// source: pm/v1/actions.proto

package pmv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ActionType int32

const (
	ActionType_ACTION_TYPE_UNSPECIFIED ActionType = 0
	// Package management (1-99)
	ActionType_ACTION_TYPE_PACKAGE    ActionType = 1 // Generic package (apt/dnf/pacman based on distro)
	ActionType_ACTION_TYPE_UPDATE     ActionType = 2 // System-wide package update (respects pinning)
	ActionType_ACTION_TYPE_REPOSITORY ActionType = 3 // External repository configuration
	// Application installation (100-199)
	ActionType_ACTION_TYPE_APP_IMAGE ActionType = 100 // AppImage
	ActionType_ACTION_TYPE_DEB       ActionType = 101 // Direct .deb
	ActionType_ACTION_TYPE_RPM       ActionType = 102 // Direct .rpm
	ActionType_ACTION_TYPE_FLATPAK   ActionType = 103 // Flatpak application
	// Scripts (200-299)
	ActionType_ACTION_TYPE_SHELL ActionType = 200 // Shell script
	// Services (300-399)
	ActionType_ACTION_TYPE_SYSTEMD ActionType = 300 // Systemd unit
	// Files (400-499)
	ActionType_ACTION_TYPE_FILE      ActionType = 400 // File management
	ActionType_ACTION_TYPE_DIRECTORY ActionType = 401 // Directory management
	// Instant actions (500-599) â€” agent-builtin, no parameters
	ActionType_ACTION_TYPE_REBOOT ActionType = 500 // Reboot the device (5-minute delay)
	ActionType_ACTION_TYPE_SYNC   ActionType = 501 // Trigger immediate agent sync
	// System management (600-699)
	ActionType_ACTION_TYPE_USER ActionType = 600 // User account management
	// SSH access management (700-799)
	ActionType_ACTION_TYPE_SSH  ActionType = 700 // SSH access configuration
	ActionType_ACTION_TYPE_SSHD ActionType = 701 // SSH daemon configuration
	// Privilege management (800-899)
	ActionType_ACTION_TYPE_SUDO ActionType = 800 // Sudoers policy management
	// Password management (900-999)
	ActionType_ACTION_TYPE_LPS ActionType = 900 // Linux Password Solution
)

// Enum value maps for ActionType.
var (
	ActionType_name = map[int32]string{
		0:   "ACTION_TYPE_UNSPECIFIED",
		1:   "ACTION_TYPE_PACKAGE",
		2:   "ACTION_TYPE_UPDATE",
		3:   "ACTION_TYPE_REPOSITORY",
		100: "ACTION_TYPE_APP_IMAGE",
		101: "ACTION_TYPE_DEB",
		102: "ACTION_TYPE_RPM",
		103: "ACTION_TYPE_FLATPAK",
		200: "ACTION_TYPE_SHELL",
		300: "ACTION_TYPE_SYSTEMD",
		400: "ACTION_TYPE_FILE",
		401: "ACTION_TYPE_DIRECTORY",
		500: "ACTION_TYPE_REBOOT",
		501: "ACTION_TYPE_SYNC",
		600: "ACTION_TYPE_USER",
		700: "ACTION_TYPE_SSH",
		701: "ACTION_TYPE_SSHD",
		800: "ACTION_TYPE_SUDO",
		900: "ACTION_TYPE_LPS",
	}
	ActionType_value = map[string]int32{
		"ACTION_TYPE_UNSPECIFIED": 0,
		"ACTION_TYPE_PACKAGE":     1,
		"ACTION_TYPE_UPDATE":      2,
		"ACTION_TYPE_REPOSITORY":  3,
		"ACTION_TYPE_APP_IMAGE":   100,
		"ACTION_TYPE_DEB":         101,
		"ACTION_TYPE_RPM":         102,
		"ACTION_TYPE_FLATPAK":     103,
		"ACTION_TYPE_SHELL":       200,
		"ACTION_TYPE_SYSTEMD":     300,
		"ACTION_TYPE_FILE":        400,
		"ACTION_TYPE_DIRECTORY":   401,
		"ACTION_TYPE_REBOOT":      500,
		"ACTION_TYPE_SYNC":        501,
		"ACTION_TYPE_USER":        600,
		"ACTION_TYPE_SSH":         700,
		"ACTION_TYPE_SSHD":        701,
		"ACTION_TYPE_SUDO":        800,
		"ACTION_TYPE_LPS":         900,
	}
)

func (x ActionType) Enum() *ActionType {
	p := new(ActionType)
	*p = x
	return p
}

func (x ActionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ActionType) Descriptor() protoreflect.EnumDescriptor {
	return file_pm_v1_actions_proto_enumTypes[0].Descriptor()
}

func (ActionType) Type() protoreflect.EnumType {
	return &file_pm_v1_actions_proto_enumTypes[0]
}

func (x ActionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ActionType.Descriptor instead.
func (ActionType) EnumDescriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{0}
}

type SystemdUnitState int32

const (
	SystemdUnitState_SYSTEMD_UNIT_STATE_UNSPECIFIED SystemdUnitState = 0
	SystemdUnitState_SYSTEMD_UNIT_STATE_STARTED     SystemdUnitState = 1
	SystemdUnitState_SYSTEMD_UNIT_STATE_STOPPED     SystemdUnitState = 2
	SystemdUnitState_SYSTEMD_UNIT_STATE_RESTARTED   SystemdUnitState = 3
)

// Enum value maps for SystemdUnitState.
var (
	SystemdUnitState_name = map[int32]string{
		0: "SYSTEMD_UNIT_STATE_UNSPECIFIED",
		1: "SYSTEMD_UNIT_STATE_STARTED",
		2: "SYSTEMD_UNIT_STATE_STOPPED",
		3: "SYSTEMD_UNIT_STATE_RESTARTED",
	}
	SystemdUnitState_value = map[string]int32{
		"SYSTEMD_UNIT_STATE_UNSPECIFIED": 0,
		"SYSTEMD_UNIT_STATE_STARTED":     1,
		"SYSTEMD_UNIT_STATE_STOPPED":     2,
		"SYSTEMD_UNIT_STATE_RESTARTED":   3,
	}
)

func (x SystemdUnitState) Enum() *SystemdUnitState {
	p := new(SystemdUnitState)
	*p = x
	return p
}

func (x SystemdUnitState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SystemdUnitState) Descriptor() protoreflect.EnumDescriptor {
	return file_pm_v1_actions_proto_enumTypes[1].Descriptor()
}

func (SystemdUnitState) Type() protoreflect.EnumType {
	return &file_pm_v1_actions_proto_enumTypes[1]
}

func (x SystemdUnitState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SystemdUnitState.Descriptor instead.
func (SystemdUnitState) EnumDescriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{1}
}

// SudoAccessLevel defines the level of sudo access granted.
type SudoAccessLevel int32

const (
	SudoAccessLevel_SUDO_ACCESS_LEVEL_UNSPECIFIED SudoAccessLevel = 0
	SudoAccessLevel_SUDO_ACCESS_LEVEL_FULL        SudoAccessLevel = 1 // Unrestricted sudo (password required)
	SudoAccessLevel_SUDO_ACCESS_LEVEL_LIMITED     SudoAccessLevel = 2 // System management commands only (NOPASSWD)
	SudoAccessLevel_SUDO_ACCESS_LEVEL_CUSTOM      SudoAccessLevel = 3 // Admin-defined sudoers rules
)

// Enum value maps for SudoAccessLevel.
var (
	SudoAccessLevel_name = map[int32]string{
		0: "SUDO_ACCESS_LEVEL_UNSPECIFIED",
		1: "SUDO_ACCESS_LEVEL_FULL",
		2: "SUDO_ACCESS_LEVEL_LIMITED",
		3: "SUDO_ACCESS_LEVEL_CUSTOM",
	}
	SudoAccessLevel_value = map[string]int32{
		"SUDO_ACCESS_LEVEL_UNSPECIFIED": 0,
		"SUDO_ACCESS_LEVEL_FULL":        1,
		"SUDO_ACCESS_LEVEL_LIMITED":     2,
		"SUDO_ACCESS_LEVEL_CUSTOM":      3,
	}
)

func (x SudoAccessLevel) Enum() *SudoAccessLevel {
	p := new(SudoAccessLevel)
	*p = x
	return p
}

func (x SudoAccessLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SudoAccessLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_pm_v1_actions_proto_enumTypes[2].Descriptor()
}

func (SudoAccessLevel) Type() protoreflect.EnumType {
	return &file_pm_v1_actions_proto_enumTypes[2]
}

func (x SudoAccessLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SudoAccessLevel.Descriptor instead.
func (SudoAccessLevel) EnumDescriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{2}
}

// LpsPasswordComplexity defines the character set for generated passwords.
type LpsPasswordComplexity int32

const (
	LpsPasswordComplexity_LPS_PASSWORD_COMPLEXITY_UNSPECIFIED  LpsPasswordComplexity = 0
	LpsPasswordComplexity_LPS_PASSWORD_COMPLEXITY_ALPHANUMERIC LpsPasswordComplexity = 1 // a-z, A-Z, 0-9
	LpsPasswordComplexity_LPS_PASSWORD_COMPLEXITY_COMPLEX      LpsPasswordComplexity = 2 // a-z, A-Z, 0-9, special characters
)

// Enum value maps for LpsPasswordComplexity.
var (
	LpsPasswordComplexity_name = map[int32]string{
		0: "LPS_PASSWORD_COMPLEXITY_UNSPECIFIED",
		1: "LPS_PASSWORD_COMPLEXITY_ALPHANUMERIC",
		2: "LPS_PASSWORD_COMPLEXITY_COMPLEX",
	}
	LpsPasswordComplexity_value = map[string]int32{
		"LPS_PASSWORD_COMPLEXITY_UNSPECIFIED":  0,
		"LPS_PASSWORD_COMPLEXITY_ALPHANUMERIC": 1,
		"LPS_PASSWORD_COMPLEXITY_COMPLEX":      2,
	}
)

func (x LpsPasswordComplexity) Enum() *LpsPasswordComplexity {
	p := new(LpsPasswordComplexity)
	*p = x
	return p
}

func (x LpsPasswordComplexity) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LpsPasswordComplexity) Descriptor() protoreflect.EnumDescriptor {
	return file_pm_v1_actions_proto_enumTypes[3].Descriptor()
}

func (LpsPasswordComplexity) Type() protoreflect.EnumType {
	return &file_pm_v1_actions_proto_enumTypes[3]
}

func (x LpsPasswordComplexity) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LpsPasswordComplexity.Descriptor instead.
func (LpsPasswordComplexity) EnumDescriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{3}
}

type Action struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// @gotags: validate:"required"
	Id *ActionId `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" validate:"required"`
	// @gotags: validate:"required,ne=0"
	Type ActionType `protobuf:"varint,2,opt,name=type,proto3,enum=pm.v1.ActionType" json:"type,omitempty" validate:"required,ne=0"`
	// @gotags: validate:"omitempty"
	DesiredState DesiredState `protobuf:"varint,3,opt,name=desired_state,json=desiredState,proto3,enum=pm.v1.DesiredState" json:"desired_state,omitempty" validate:"omitempty"`
	// @gotags: validate:"omitempty,gte=0,lte=3600"
	TimeoutSeconds int32 `protobuf:"varint,4,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty" validate:"omitempty,gte=0,lte=3600"`
	// Scheduling configuration for autonomous agent execution
	// @gotags: validate:"omitempty"
	Schedule *ActionSchedule `protobuf:"bytes,5,opt,name=schedule,proto3" json:"schedule,omitempty" validate:"omitempty"`
	// Type-specific parameters
	//
	// Types that are valid to be assigned to Params:
	//
	//	*Action_Package
	//	*Action_App
	//	*Action_Shell
	//	*Action_Systemd
	//	*Action_File
	//	*Action_Update
	//	*Action_Repository
	//	*Action_Flatpak
	//	*Action_Directory
	//	*Action_User
	//	*Action_Ssh
	//	*Action_Sshd
	//	*Action_Sudo
	//	*Action_Lps
	Params isAction_Params `protobuf_oneof:"params"`
	// ECDSA signature over canonical action payload (signed by CA key).
	// Used to verify actions were created by the control server.
	Signature []byte `protobuf:"bytes,20,opt,name=signature,proto3" json:"signature,omitempty"`
	// Canonical JSON params used for signature verification.
	ParamsCanonical []byte `protobuf:"bytes,21,opt,name=params_canonical,json=paramsCanonical,proto3" json:"params_canonical,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Action) Reset() {
	*x = Action{}
	mi := &file_pm_v1_actions_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Action) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Action) ProtoMessage() {}

func (x *Action) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Action.ProtoReflect.Descriptor instead.
func (*Action) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{0}
}

func (x *Action) GetId() *ActionId {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *Action) GetType() ActionType {
	if x != nil {
		return x.Type
	}
	return ActionType_ACTION_TYPE_UNSPECIFIED
}

func (x *Action) GetDesiredState() DesiredState {
	if x != nil {
		return x.DesiredState
	}
	return DesiredState_DESIRED_STATE_PRESENT
}

func (x *Action) GetTimeoutSeconds() int32 {
	if x != nil {
		return x.TimeoutSeconds
	}
	return 0
}

func (x *Action) GetSchedule() *ActionSchedule {
	if x != nil {
		return x.Schedule
	}
	return nil
}

func (x *Action) GetParams() isAction_Params {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *Action) GetPackage() *PackageParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Package); ok {
			return x.Package
		}
	}
	return nil
}

func (x *Action) GetApp() *AppInstallParams {
	if x != nil {
		if x, ok := x.Params.(*Action_App); ok {
			return x.App
		}
	}
	return nil
}

func (x *Action) GetShell() *ShellParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Shell); ok {
			return x.Shell
		}
	}
	return nil
}

func (x *Action) GetSystemd() *SystemdParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Systemd); ok {
			return x.Systemd
		}
	}
	return nil
}

func (x *Action) GetFile() *FileParams {
	if x != nil {
		if x, ok := x.Params.(*Action_File); ok {
			return x.File
		}
	}
	return nil
}

func (x *Action) GetUpdate() *UpdateParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Update); ok {
			return x.Update
		}
	}
	return nil
}

func (x *Action) GetRepository() *RepositoryParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Repository); ok {
			return x.Repository
		}
	}
	return nil
}

func (x *Action) GetFlatpak() *FlatpakParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Flatpak); ok {
			return x.Flatpak
		}
	}
	return nil
}

func (x *Action) GetDirectory() *DirectoryParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Directory); ok {
			return x.Directory
		}
	}
	return nil
}

func (x *Action) GetUser() *UserParams {
	if x != nil {
		if x, ok := x.Params.(*Action_User); ok {
			return x.User
		}
	}
	return nil
}

func (x *Action) GetSsh() *SshParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Ssh); ok {
			return x.Ssh
		}
	}
	return nil
}

func (x *Action) GetSshd() *SshdParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Sshd); ok {
			return x.Sshd
		}
	}
	return nil
}

func (x *Action) GetSudo() *SudoParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Sudo); ok {
			return x.Sudo
		}
	}
	return nil
}

func (x *Action) GetLps() *LpsParams {
	if x != nil {
		if x, ok := x.Params.(*Action_Lps); ok {
			return x.Lps
		}
	}
	return nil
}

func (x *Action) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *Action) GetParamsCanonical() []byte {
	if x != nil {
		return x.ParamsCanonical
	}
	return nil
}

type isAction_Params interface {
	isAction_Params()
}

type Action_Package struct {
	Package *PackageParams `protobuf:"bytes,10,opt,name=package,proto3,oneof"`
}

type Action_App struct {
	App *AppInstallParams `protobuf:"bytes,11,opt,name=app,proto3,oneof"`
}

type Action_Shell struct {
	Shell *ShellParams `protobuf:"bytes,12,opt,name=shell,proto3,oneof"`
}

type Action_Systemd struct {
	Systemd *SystemdParams `protobuf:"bytes,13,opt,name=systemd,proto3,oneof"`
}

type Action_File struct {
	File *FileParams `protobuf:"bytes,14,opt,name=file,proto3,oneof"`
}

type Action_Update struct {
	Update *UpdateParams `protobuf:"bytes,15,opt,name=update,proto3,oneof"`
}

type Action_Repository struct {
	Repository *RepositoryParams `protobuf:"bytes,16,opt,name=repository,proto3,oneof"`
}

type Action_Flatpak struct {
	Flatpak *FlatpakParams `protobuf:"bytes,17,opt,name=flatpak,proto3,oneof"`
}

type Action_Directory struct {
	Directory *DirectoryParams `protobuf:"bytes,18,opt,name=directory,proto3,oneof"`
}

type Action_User struct {
	User *UserParams `protobuf:"bytes,19,opt,name=user,proto3,oneof"`
}

type Action_Ssh struct {
	Ssh *SshParams `protobuf:"bytes,22,opt,name=ssh,proto3,oneof"`
}

type Action_Sshd struct {
	Sshd *SshdParams `protobuf:"bytes,23,opt,name=sshd,proto3,oneof"`
}

type Action_Sudo struct {
	Sudo *SudoParams `protobuf:"bytes,24,opt,name=sudo,proto3,oneof"`
}

type Action_Lps struct {
	Lps *LpsParams `protobuf:"bytes,25,opt,name=lps,proto3,oneof"`
}

func (*Action_Package) isAction_Params() {}

func (*Action_App) isAction_Params() {}

func (*Action_Shell) isAction_Params() {}

func (*Action_Systemd) isAction_Params() {}

func (*Action_File) isAction_Params() {}

func (*Action_Update) isAction_Params() {}

func (*Action_Repository) isAction_Params() {}

func (*Action_Flatpak) isAction_Params() {}

func (*Action_Directory) isAction_Params() {}

func (*Action_User) isAction_Params() {}

func (*Action_Ssh) isAction_Params() {}

func (*Action_Sshd) isAction_Params() {}

func (*Action_Sudo) isAction_Params() {}

func (*Action_Lps) isAction_Params() {}

// ActionSchedule defines when an action should be executed by the agent.
// Actions run autonomously on the agent even without server connection.
type ActionSchedule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Cron expression for scheduled execution (e.g., "0 3 * * *" for 3am daily)
	// If empty, uses default_interval_hours instead.
	// @gotags: validate:"omitempty,max=128"
	Cron string `protobuf:"bytes,1,opt,name=cron,proto3" json:"cron,omitempty" validate:"omitempty,max=128"`
	// Default interval in hours between executions (default: 8 hours for drift prevention)
	// Used when cron is not specified.
	// @gotags: validate:"omitempty,gte=0,lte=8760"
	IntervalHours int32 `protobuf:"varint,2,opt,name=interval_hours,json=intervalHours,proto3" json:"interval_hours,omitempty" validate:"omitempty,gte=0,lte=8760"`
	// Whether to run immediately when the action is first received
	// @gotags: validate:"omitempty"
	RunOnAssign bool `protobuf:"varint,3,opt,name=run_on_assign,json=runOnAssign,proto3" json:"run_on_assign,omitempty" validate:"omitempty"`
	// Whether to skip execution if the previous run was successful and no changes detected
	// @gotags: validate:"omitempty"
	SkipIfUnchanged bool `protobuf:"varint,4,opt,name=skip_if_unchanged,json=skipIfUnchanged,proto3" json:"skip_if_unchanged,omitempty" validate:"omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ActionSchedule) Reset() {
	*x = ActionSchedule{}
	mi := &file_pm_v1_actions_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActionSchedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActionSchedule) ProtoMessage() {}

func (x *ActionSchedule) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActionSchedule.ProtoReflect.Descriptor instead.
func (*ActionSchedule) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{1}
}

func (x *ActionSchedule) GetCron() string {
	if x != nil {
		return x.Cron
	}
	return ""
}

func (x *ActionSchedule) GetIntervalHours() int32 {
	if x != nil {
		return x.IntervalHours
	}
	return 0
}

func (x *ActionSchedule) GetRunOnAssign() bool {
	if x != nil {
		return x.RunOnAssign
	}
	return false
}

func (x *ActionSchedule) GetSkipIfUnchanged() bool {
	if x != nil {
		return x.SkipIfUnchanged
	}
	return false
}

type PackageParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Generic package name (used if manager-specific names not provided)
	// If set, this name is used for all package managers.
	// @gotags: validate:"omitempty,max=255"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" validate:"omitempty,max=255"`
	// @gotags: validate:"omitempty,max=128"
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty" validate:"omitempty,max=128"`
	// @gotags: validate:"omitempty"
	AllowDowngrade bool `protobuf:"varint,3,opt,name=allow_downgrade,json=allowDowngrade,proto3" json:"allow_downgrade,omitempty" validate:"omitempty"`
	// @gotags: validate:"omitempty"
	Pin bool `protobuf:"varint,4,opt,name=pin,proto3" json:"pin,omitempty" validate:"omitempty"`
	// Manager-specific package names (override generic name)
	// If a manager-specific name is empty, that manager will be skipped.
	// @gotags: validate:"omitempty,max=255"
	AptName string `protobuf:"bytes,10,opt,name=apt_name,json=aptName,proto3" json:"apt_name,omitempty" validate:"omitempty,max=255"` // Debian/Ubuntu (apt/apt-get)
	// @gotags: validate:"omitempty,max=255"
	DnfName string `protobuf:"bytes,11,opt,name=dnf_name,json=dnfName,proto3" json:"dnf_name,omitempty" validate:"omitempty,max=255"` // Fedora/RHEL (dnf/yum)
	// @gotags: validate:"omitempty,max=255"
	PacmanName string `protobuf:"bytes,12,opt,name=pacman_name,json=pacmanName,proto3" json:"pacman_name,omitempty" validate:"omitempty,max=255"` // Arch Linux (pacman)
	// @gotags: validate:"omitempty,max=255"
	ZypperName    string `protobuf:"bytes,13,opt,name=zypper_name,json=zypperName,proto3" json:"zypper_name,omitempty" validate:"omitempty,max=255"` // openSUSE (zypper)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PackageParams) Reset() {
	*x = PackageParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PackageParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackageParams) ProtoMessage() {}

func (x *PackageParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackageParams.ProtoReflect.Descriptor instead.
func (*PackageParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{2}
}

func (x *PackageParams) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PackageParams) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *PackageParams) GetAllowDowngrade() bool {
	if x != nil {
		return x.AllowDowngrade
	}
	return false
}

func (x *PackageParams) GetPin() bool {
	if x != nil {
		return x.Pin
	}
	return false
}

func (x *PackageParams) GetAptName() string {
	if x != nil {
		return x.AptName
	}
	return ""
}

func (x *PackageParams) GetDnfName() string {
	if x != nil {
		return x.DnfName
	}
	return ""
}

func (x *PackageParams) GetPacmanName() string {
	if x != nil {
		return x.PacmanName
	}
	return ""
}

func (x *PackageParams) GetZypperName() string {
	if x != nil {
		return x.ZypperName
	}
	return ""
}

type AppInstallParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// @gotags: validate:"required,url"
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty" validate:"required,url"`
	// @gotags: validate:"omitempty,len=64,hexadecimal"
	ChecksumSha256 string `protobuf:"bytes,2,opt,name=checksum_sha256,json=checksumSha256,proto3" json:"checksum_sha256,omitempty" validate:"omitempty,len=64,hexadecimal"`
	// @gotags: validate:"omitempty,startswith=/"
	InstallPath   string `protobuf:"bytes,3,opt,name=install_path,json=installPath,proto3" json:"install_path,omitempty" validate:"omitempty,startswith=/"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppInstallParams) Reset() {
	*x = AppInstallParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppInstallParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppInstallParams) ProtoMessage() {}

func (x *AppInstallParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppInstallParams.ProtoReflect.Descriptor instead.
func (*AppInstallParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{3}
}

func (x *AppInstallParams) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *AppInstallParams) GetChecksumSha256() string {
	if x != nil {
		return x.ChecksumSha256
	}
	return ""
}

func (x *AppInstallParams) GetInstallPath() string {
	if x != nil {
		return x.InstallPath
	}
	return ""
}

type ShellParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// @gotags: validate:"required,max=1048576"
	Script string `protobuf:"bytes,1,opt,name=script,proto3" json:"script,omitempty" validate:"required,max=1048576"`
	// @gotags: validate:"omitempty,max=255"
	Interpreter string `protobuf:"bytes,2,opt,name=interpreter,proto3" json:"interpreter,omitempty" validate:"omitempty,max=255"`
	// @gotags: validate:"omitempty"
	RunAsRoot bool `protobuf:"varint,3,opt,name=run_as_root,json=runAsRoot,proto3" json:"run_as_root,omitempty" validate:"omitempty"`
	// @gotags: validate:"omitempty,startswith=/"
	WorkingDirectory string `protobuf:"bytes,4,opt,name=working_directory,json=workingDirectory,proto3" json:"working_directory,omitempty" validate:"omitempty,startswith=/"`
	// @gotags: validate:"omitempty,dive,keys,max=255,endkeys,max=4096"
	Environment   map[string]string `protobuf:"bytes,5,rep,name=environment,proto3" json:"environment,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value" validate:"omitempty,dive,keys,max=255,endkeys,max=4096"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShellParams) Reset() {
	*x = ShellParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShellParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShellParams) ProtoMessage() {}

func (x *ShellParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShellParams.ProtoReflect.Descriptor instead.
func (*ShellParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{4}
}

func (x *ShellParams) GetScript() string {
	if x != nil {
		return x.Script
	}
	return ""
}

func (x *ShellParams) GetInterpreter() string {
	if x != nil {
		return x.Interpreter
	}
	return ""
}

func (x *ShellParams) GetRunAsRoot() bool {
	if x != nil {
		return x.RunAsRoot
	}
	return false
}

func (x *ShellParams) GetWorkingDirectory() string {
	if x != nil {
		return x.WorkingDirectory
	}
	return ""
}

func (x *ShellParams) GetEnvironment() map[string]string {
	if x != nil {
		return x.Environment
	}
	return nil
}

type SystemdParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// @gotags: validate:"required,min=1,max=255"
	UnitName string `protobuf:"bytes,1,opt,name=unit_name,json=unitName,proto3" json:"unit_name,omitempty" validate:"required,min=1,max=255"`
	// @gotags: validate:"omitempty"
	DesiredState SystemdUnitState `protobuf:"varint,2,opt,name=desired_state,json=desiredState,proto3,enum=pm.v1.SystemdUnitState" json:"desired_state,omitempty" validate:"omitempty"`
	// @gotags: validate:"omitempty"
	Enable bool `protobuf:"varint,3,opt,name=enable,proto3" json:"enable,omitempty" validate:"omitempty"`
	// @gotags: validate:"omitempty,max=65536"
	UnitContent   string `protobuf:"bytes,4,opt,name=unit_content,json=unitContent,proto3" json:"unit_content,omitempty" validate:"omitempty,max=65536"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SystemdParams) Reset() {
	*x = SystemdParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SystemdParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SystemdParams) ProtoMessage() {}

func (x *SystemdParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SystemdParams.ProtoReflect.Descriptor instead.
func (*SystemdParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{5}
}

func (x *SystemdParams) GetUnitName() string {
	if x != nil {
		return x.UnitName
	}
	return ""
}

func (x *SystemdParams) GetDesiredState() SystemdUnitState {
	if x != nil {
		return x.DesiredState
	}
	return SystemdUnitState_SYSTEMD_UNIT_STATE_UNSPECIFIED
}

func (x *SystemdParams) GetEnable() bool {
	if x != nil {
		return x.Enable
	}
	return false
}

func (x *SystemdParams) GetUnitContent() string {
	if x != nil {
		return x.UnitContent
	}
	return ""
}

type FileParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// @gotags: validate:"required,startswith=/"
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty" validate:"required,startswith=/"`
	// @gotags: validate:"omitempty,max=10485760"
	Content string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty" validate:"omitempty,max=10485760"`
	// @gotags: validate:"omitempty,max=32"
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty" validate:"omitempty,max=32"`
	// @gotags: validate:"omitempty,max=32"
	Group string `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty" validate:"omitempty,max=32"`
	// @gotags: validate:"omitempty,max=4"
	Mode string `protobuf:"bytes,5,opt,name=mode,proto3" json:"mode,omitempty" validate:"omitempty,max=4"`
	// Managed block mode: if true, manages a content block within the file.
	// PRESENT: appends content if not already present in file.
	// ABSENT: removes only the content block, not the entire file.
	// Ownership and mode are still enforced.
	// @gotags: validate:"omitempty"
	ManagedBlock  bool `protobuf:"varint,6,opt,name=managed_block,json=managedBlock,proto3" json:"managed_block,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileParams) Reset() {
	*x = FileParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileParams) ProtoMessage() {}

func (x *FileParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileParams.ProtoReflect.Descriptor instead.
func (*FileParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{6}
}

func (x *FileParams) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *FileParams) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *FileParams) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *FileParams) GetGroup() string {
	if x != nil {
		return x.Group
	}
	return ""
}

func (x *FileParams) GetMode() string {
	if x != nil {
		return x.Mode
	}
	return ""
}

func (x *FileParams) GetManagedBlock() bool {
	if x != nil {
		return x.ManagedBlock
	}
	return false
}

// DirectoryParams configures directory management.
// Creates or removes directories with optional ownership and permissions.
type DirectoryParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Directory path (must be absolute)
	// @gotags: validate:"required,startswith=/"
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty" validate:"required,startswith=/"`
	// @gotags: validate:"omitempty,max=32"
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty" validate:"omitempty,max=32"`
	// @gotags: validate:"omitempty,max=32"
	Group string `protobuf:"bytes,3,opt,name=group,proto3" json:"group,omitempty" validate:"omitempty,max=32"`
	// @gotags: validate:"omitempty,max=4"
	Mode string `protobuf:"bytes,4,opt,name=mode,proto3" json:"mode,omitempty" validate:"omitempty,max=4"`
	// Whether to create parent directories (like mkdir -p)
	// Default: true
	// @gotags: validate:"omitempty"
	Recursive     bool `protobuf:"varint,5,opt,name=recursive,proto3" json:"recursive,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DirectoryParams) Reset() {
	*x = DirectoryParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DirectoryParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DirectoryParams) ProtoMessage() {}

func (x *DirectoryParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DirectoryParams.ProtoReflect.Descriptor instead.
func (*DirectoryParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{7}
}

func (x *DirectoryParams) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *DirectoryParams) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *DirectoryParams) GetGroup() string {
	if x != nil {
		return x.Group
	}
	return ""
}

func (x *DirectoryParams) GetMode() string {
	if x != nil {
		return x.Mode
	}
	return ""
}

func (x *DirectoryParams) GetRecursive() bool {
	if x != nil {
		return x.Recursive
	}
	return false
}

// UpdateParams configures system-wide package updates.
// Respects version pinning (apt-mark hold / dnf versionlock).
type UpdateParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// @gotags: validate:"omitempty"
	SecurityOnly bool `protobuf:"varint,1,opt,name=security_only,json=securityOnly,proto3" json:"security_only,omitempty" validate:"omitempty"` // Only install security updates (if supported)
	// @gotags: validate:"omitempty"
	Autoremove bool `protobuf:"varint,2,opt,name=autoremove,proto3" json:"autoremove,omitempty" validate:"omitempty"` // Remove unused dependencies after update
	// @gotags: validate:"omitempty"
	RebootIfRequired bool `protobuf:"varint,3,opt,name=reboot_if_required,json=rebootIfRequired,proto3" json:"reboot_if_required,omitempty" validate:"omitempty"` // Reboot system if updates require it
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *UpdateParams) Reset() {
	*x = UpdateParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateParams) ProtoMessage() {}

func (x *UpdateParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateParams.ProtoReflect.Descriptor instead.
func (*UpdateParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{8}
}

func (x *UpdateParams) GetSecurityOnly() bool {
	if x != nil {
		return x.SecurityOnly
	}
	return false
}

func (x *UpdateParams) GetAutoremove() bool {
	if x != nil {
		return x.Autoremove
	}
	return false
}

func (x *UpdateParams) GetRebootIfRequired() bool {
	if x != nil {
		return x.RebootIfRequired
	}
	return false
}

// FlatpakParams configures Flatpak application installation.
// Similar to AppImage but uses the Flatpak package manager.
type FlatpakParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Application ID (e.g., "org.mozilla.firefox", "com.spotify.Client")
	// @gotags: validate:"required,min=1,max=255"
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty" validate:"required,min=1,max=255"`
	// Remote/repository name (default: "flathub")
	// @gotags: validate:"omitempty,max=64"
	Remote string `protobuf:"bytes,2,opt,name=remote,proto3" json:"remote,omitempty" validate:"omitempty,max=64"`
	// Whether to install system-wide (true) or user-only (false)
	// Default: true (system-wide)
	// @gotags: validate:"omitempty"
	SystemWide bool `protobuf:"varint,3,opt,name=system_wide,json=systemWide,proto3" json:"system_wide,omitempty" validate:"omitempty"`
	// Pin the application to prevent automatic updates
	// @gotags: validate:"omitempty"
	Pin           bool `protobuf:"varint,4,opt,name=pin,proto3" json:"pin,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlatpakParams) Reset() {
	*x = FlatpakParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlatpakParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlatpakParams) ProtoMessage() {}

func (x *FlatpakParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlatpakParams.ProtoReflect.Descriptor instead.
func (*FlatpakParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{9}
}

func (x *FlatpakParams) GetAppId() string {
	if x != nil {
		return x.AppId
	}
	return ""
}

func (x *FlatpakParams) GetRemote() string {
	if x != nil {
		return x.Remote
	}
	return ""
}

func (x *FlatpakParams) GetSystemWide() bool {
	if x != nil {
		return x.SystemWide
	}
	return false
}

func (x *FlatpakParams) GetPin() bool {
	if x != nil {
		return x.Pin
	}
	return false
}

// RepositoryParams configures external package repositories.
// Each package manager has its own configuration format.
type RepositoryParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Repository name/identifier (used for file naming)
	// @gotags: validate:"required,min=1,max=64,alphanum"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" validate:"required,min=1,max=64,alphanum"`
	// APT repository configuration (Debian/Ubuntu)
	// @gotags: validate:"omitempty"
	Apt *AptRepository `protobuf:"bytes,10,opt,name=apt,proto3" json:"apt,omitempty" validate:"omitempty"`
	// DNF/YUM repository configuration (Fedora/RHEL)
	// @gotags: validate:"omitempty"
	Dnf *DnfRepository `protobuf:"bytes,11,opt,name=dnf,proto3" json:"dnf,omitempty" validate:"omitempty"`
	// Pacman repository configuration (Arch Linux)
	// @gotags: validate:"omitempty"
	Pacman *PacmanRepository `protobuf:"bytes,12,opt,name=pacman,proto3" json:"pacman,omitempty" validate:"omitempty"`
	// Zypper repository configuration (openSUSE)
	// @gotags: validate:"omitempty"
	Zypper        *ZypperRepository `protobuf:"bytes,13,opt,name=zypper,proto3" json:"zypper,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RepositoryParams) Reset() {
	*x = RepositoryParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RepositoryParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RepositoryParams) ProtoMessage() {}

func (x *RepositoryParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RepositoryParams.ProtoReflect.Descriptor instead.
func (*RepositoryParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{10}
}

func (x *RepositoryParams) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RepositoryParams) GetApt() *AptRepository {
	if x != nil {
		return x.Apt
	}
	return nil
}

func (x *RepositoryParams) GetDnf() *DnfRepository {
	if x != nil {
		return x.Dnf
	}
	return nil
}

func (x *RepositoryParams) GetPacman() *PacmanRepository {
	if x != nil {
		return x.Pacman
	}
	return nil
}

func (x *RepositoryParams) GetZypper() *ZypperRepository {
	if x != nil {
		return x.Zypper
	}
	return nil
}

// AptRepository configures a Debian/Ubuntu APT repository.
type AptRepository struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Repository URL (e.g., "https://packages.example.com/apt")
	// @gotags: validate:"required_without=Disabled,omitempty,url"
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty" validate:"required_without=Disabled,omitempty,url"`
	// Distribution codename (e.g., "jammy", "bookworm")
	// @gotags: validate:"omitempty,max=64"
	Distribution string `protobuf:"bytes,2,opt,name=distribution,proto3" json:"distribution,omitempty" validate:"omitempty,max=64"`
	// Components (e.g., "main", "contrib", "non-free")
	// @gotags: validate:"omitempty,dive,max=64"
	Components []string `protobuf:"bytes,3,rep,name=components,proto3" json:"components,omitempty" validate:"omitempty,dive,max=64"`
	// GPG key URL for repository signing
	// @gotags: validate:"omitempty,url"
	GpgKeyUrl string `protobuf:"bytes,4,opt,name=gpg_key_url,json=gpgKeyUrl,proto3" json:"gpg_key_url,omitempty" validate:"omitempty,url"`
	// GPG key content (ASCII-armored, alternative to gpg_key_url)
	// @gotags: validate:"omitempty,max=65536"
	GpgKey string `protobuf:"bytes,5,opt,name=gpg_key,json=gpgKey,proto3" json:"gpg_key,omitempty" validate:"omitempty,max=65536"`
	// Whether to use signed-by (modern) or trusted=yes (legacy, less secure)
	// @gotags: validate:"omitempty"
	Trusted bool `protobuf:"varint,6,opt,name=trusted,proto3" json:"trusted,omitempty" validate:"omitempty"`
	// Architecture filter (e.g., "amd64", "arm64")
	// @gotags: validate:"omitempty,max=32"
	Arch string `protobuf:"bytes,7,opt,name=arch,proto3" json:"arch,omitempty" validate:"omitempty,max=32"`
	// Set to true to disable/skip this repository manager
	// @gotags: validate:"omitempty"
	Disabled      bool `protobuf:"varint,8,opt,name=disabled,proto3" json:"disabled,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AptRepository) Reset() {
	*x = AptRepository{}
	mi := &file_pm_v1_actions_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AptRepository) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AptRepository) ProtoMessage() {}

func (x *AptRepository) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AptRepository.ProtoReflect.Descriptor instead.
func (*AptRepository) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{11}
}

func (x *AptRepository) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *AptRepository) GetDistribution() string {
	if x != nil {
		return x.Distribution
	}
	return ""
}

func (x *AptRepository) GetComponents() []string {
	if x != nil {
		return x.Components
	}
	return nil
}

func (x *AptRepository) GetGpgKeyUrl() string {
	if x != nil {
		return x.GpgKeyUrl
	}
	return ""
}

func (x *AptRepository) GetGpgKey() string {
	if x != nil {
		return x.GpgKey
	}
	return ""
}

func (x *AptRepository) GetTrusted() bool {
	if x != nil {
		return x.Trusted
	}
	return false
}

func (x *AptRepository) GetArch() string {
	if x != nil {
		return x.Arch
	}
	return ""
}

func (x *AptRepository) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

// DnfRepository configures a Fedora/RHEL DNF/YUM repository.
type DnfRepository struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Base URL for the repository
	// @gotags: validate:"required_without=Disabled,omitempty,url"
	Baseurl string `protobuf:"bytes,1,opt,name=baseurl,proto3" json:"baseurl,omitempty" validate:"required_without=Disabled,omitempty,url"`
	// Repository description
	// @gotags: validate:"omitempty,max=255"
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" validate:"omitempty,max=255"`
	// Whether the repository is enabled (default true)
	// @gotags: validate:"omitempty"
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty" validate:"omitempty"`
	// Whether to check GPG signatures
	// @gotags: validate:"omitempty"
	Gpgcheck bool `protobuf:"varint,4,opt,name=gpgcheck,proto3" json:"gpgcheck,omitempty" validate:"omitempty"`
	// GPG key URL
	// @gotags: validate:"omitempty,url"
	Gpgkey string `protobuf:"bytes,5,opt,name=gpgkey,proto3" json:"gpgkey,omitempty" validate:"omitempty,url"`
	// Module hotfixes (for modular content)
	// @gotags: validate:"omitempty"
	ModuleHotfixes bool `protobuf:"varint,6,opt,name=module_hotfixes,json=moduleHotfixes,proto3" json:"module_hotfixes,omitempty" validate:"omitempty"`
	// Set to true to disable/skip this repository manager
	// @gotags: validate:"omitempty"
	Disabled      bool `protobuf:"varint,7,opt,name=disabled,proto3" json:"disabled,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DnfRepository) Reset() {
	*x = DnfRepository{}
	mi := &file_pm_v1_actions_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DnfRepository) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DnfRepository) ProtoMessage() {}

func (x *DnfRepository) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DnfRepository.ProtoReflect.Descriptor instead.
func (*DnfRepository) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{12}
}

func (x *DnfRepository) GetBaseurl() string {
	if x != nil {
		return x.Baseurl
	}
	return ""
}

func (x *DnfRepository) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *DnfRepository) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *DnfRepository) GetGpgcheck() bool {
	if x != nil {
		return x.Gpgcheck
	}
	return false
}

func (x *DnfRepository) GetGpgkey() string {
	if x != nil {
		return x.Gpgkey
	}
	return ""
}

func (x *DnfRepository) GetModuleHotfixes() bool {
	if x != nil {
		return x.ModuleHotfixes
	}
	return false
}

func (x *DnfRepository) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

// PacmanRepository configures an Arch Linux pacman repository.
type PacmanRepository struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server URL (can include $repo and $arch variables)
	// @gotags: validate:"required_without=Disabled,omitempty,url"
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty" validate:"required_without=Disabled,omitempty,url"`
	// SigLevel (e.g., "Optional TrustAll", "Required DatabaseOptional")
	// @gotags: validate:"omitempty,max=128"
	SigLevel string `protobuf:"bytes,2,opt,name=sig_level,json=sigLevel,proto3" json:"sig_level,omitempty" validate:"omitempty,max=128"`
	// Set to true to disable/skip this repository manager
	// @gotags: validate:"omitempty"
	Disabled      bool `protobuf:"varint,3,opt,name=disabled,proto3" json:"disabled,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacmanRepository) Reset() {
	*x = PacmanRepository{}
	mi := &file_pm_v1_actions_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacmanRepository) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacmanRepository) ProtoMessage() {}

func (x *PacmanRepository) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacmanRepository.ProtoReflect.Descriptor instead.
func (*PacmanRepository) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{13}
}

func (x *PacmanRepository) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *PacmanRepository) GetSigLevel() string {
	if x != nil {
		return x.SigLevel
	}
	return ""
}

func (x *PacmanRepository) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

// ZypperRepository configures an openSUSE zypper repository.
type ZypperRepository struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Repository URL
	// @gotags: validate:"required_without=Disabled,omitempty,url"
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty" validate:"required_without=Disabled,omitempty,url"`
	// Repository description/alias
	// @gotags: validate:"omitempty,max=255"
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" validate:"omitempty,max=255"`
	// Whether to enable the repository (default true)
	// @gotags: validate:"omitempty"
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty" validate:"omitempty"`
	// Whether to auto-refresh the repository
	// @gotags: validate:"omitempty"
	Autorefresh bool `protobuf:"varint,4,opt,name=autorefresh,proto3" json:"autorefresh,omitempty" validate:"omitempty"`
	// Whether to check GPG signatures
	// @gotags: validate:"omitempty"
	Gpgcheck bool `protobuf:"varint,5,opt,name=gpgcheck,proto3" json:"gpgcheck,omitempty" validate:"omitempty"`
	// GPG key URL
	// @gotags: validate:"omitempty,url"
	Gpgkey string `protobuf:"bytes,6,opt,name=gpgkey,proto3" json:"gpgkey,omitempty" validate:"omitempty,url"`
	// Repository type (e.g., "rpm-md", "yast2")
	// @gotags: validate:"omitempty,max=32"
	Type string `protobuf:"bytes,7,opt,name=type,proto3" json:"type,omitempty" validate:"omitempty,max=32"`
	// Set to true to disable/skip this repository manager
	// @gotags: validate:"omitempty"
	Disabled      bool `protobuf:"varint,8,opt,name=disabled,proto3" json:"disabled,omitempty" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZypperRepository) Reset() {
	*x = ZypperRepository{}
	mi := &file_pm_v1_actions_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZypperRepository) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZypperRepository) ProtoMessage() {}

func (x *ZypperRepository) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZypperRepository.ProtoReflect.Descriptor instead.
func (*ZypperRepository) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{14}
}

func (x *ZypperRepository) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *ZypperRepository) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ZypperRepository) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ZypperRepository) GetAutorefresh() bool {
	if x != nil {
		return x.Autorefresh
	}
	return false
}

func (x *ZypperRepository) GetGpgcheck() bool {
	if x != nil {
		return x.Gpgcheck
	}
	return false
}

func (x *ZypperRepository) GetGpgkey() string {
	if x != nil {
		return x.Gpgkey
	}
	return ""
}

func (x *ZypperRepository) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ZypperRepository) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

// UserParams configures user account management.
// Supports creating, updating, deactivating, and removing user accounts.
type UserParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Username (required)
	// @gotags: validate:"required,min=1,max=32,alphanum"
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty" validate:"required,min=1,max=32,alphanum"`
	// User ID (optional - system assigns if not specified)
	// @gotags: validate:"omitempty,gte=0,lte=65534"
	Uid int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty" validate:"omitempty,gte=0,lte=65534"`
	// Primary group ID (optional - creates user's own group if not specified)
	// @gotags: validate:"omitempty,gte=0,lte=65534"
	Gid int32 `protobuf:"varint,3,opt,name=gid,proto3" json:"gid,omitempty" validate:"omitempty,gte=0,lte=65534"`
	// Home directory path (optional - defaults to /home/<username>)
	// @gotags: validate:"omitempty,startswith=/"
	HomeDir string `protobuf:"bytes,4,opt,name=home_dir,json=homeDir,proto3" json:"home_dir,omitempty" validate:"omitempty,startswith=/"`
	// Login shell (optional - defaults to /bin/bash)
	// @gotags: validate:"omitempty,startswith=/"
	Shell string `protobuf:"bytes,5,opt,name=shell,proto3" json:"shell,omitempty" validate:"omitempty,startswith=/"`
	// Additional groups to add the user to
	// @gotags: validate:"omitempty,dive,max=32"
	Groups []string `protobuf:"bytes,6,rep,name=groups,proto3" json:"groups,omitempty" validate:"omitempty,dive,max=32"`
	// SSH authorized keys to add to ~/.ssh/authorized_keys
	// @gotags: validate:"omitempty,dive,max=4096"
	SshAuthorizedKeys []string `protobuf:"bytes,7,rep,name=ssh_authorized_keys,json=sshAuthorizedKeys,proto3" json:"ssh_authorized_keys,omitempty" validate:"omitempty,dive,max=4096"`
	// GECOS field / user comment (full name, etc.)
	// @gotags: validate:"omitempty,max=255"
	Comment string `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty" validate:"omitempty,max=255"`
	// Create as system user (UID < 1000, no home directory by default)
	// @gotags: validate:"omitempty"
	SystemUser bool `protobuf:"varint,9,opt,name=system_user,json=systemUser,proto3" json:"system_user,omitempty" validate:"omitempty"`
	// Create home directory (default: true for normal users, false for system users)
	// @gotags: validate:"omitempty"
	CreateHome bool `protobuf:"varint,10,opt,name=create_home,json=createHome,proto3" json:"create_home,omitempty" validate:"omitempty"`
	// Disable the user account (lock password, set shell to /usr/sbin/nologin)
	// @gotags: validate:"omitempty"
	Disabled bool `protobuf:"varint,11,opt,name=disabled,proto3" json:"disabled,omitempty" validate:"omitempty"`
	// Primary group name (alternative to gid - creates group if needed)
	// @gotags: validate:"omitempty,max=32"
	PrimaryGroup  string `protobuf:"bytes,12,opt,name=primary_group,json=primaryGroup,proto3" json:"primary_group,omitempty" validate:"omitempty,max=32"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserParams) Reset() {
	*x = UserParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserParams) ProtoMessage() {}

func (x *UserParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserParams.ProtoReflect.Descriptor instead.
func (*UserParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{15}
}

func (x *UserParams) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *UserParams) GetUid() int32 {
	if x != nil {
		return x.Uid
	}
	return 0
}

func (x *UserParams) GetGid() int32 {
	if x != nil {
		return x.Gid
	}
	return 0
}

func (x *UserParams) GetHomeDir() string {
	if x != nil {
		return x.HomeDir
	}
	return ""
}

func (x *UserParams) GetShell() string {
	if x != nil {
		return x.Shell
	}
	return ""
}

func (x *UserParams) GetGroups() []string {
	if x != nil {
		return x.Groups
	}
	return nil
}

func (x *UserParams) GetSshAuthorizedKeys() []string {
	if x != nil {
		return x.SshAuthorizedKeys
	}
	return nil
}

func (x *UserParams) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *UserParams) GetSystemUser() bool {
	if x != nil {
		return x.SystemUser
	}
	return false
}

func (x *UserParams) GetCreateHome() bool {
	if x != nil {
		return x.CreateHome
	}
	return false
}

func (x *UserParams) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *UserParams) GetPrimaryGroup() string {
	if x != nil {
		return x.PrimaryGroup
	}
	return ""
}

// SshParams configures SSH access for a user.
// Creates an sshd_config.d drop-in file with a Match Group directive.
// Each action creates a Linux group pm-ssh-{actionId} and users are added
// to the group. SSH keys and home directory are managed by the User action type.
type SshParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated: use users field instead. Kept for backward compatibility.
	// @gotags: validate:"omitempty,max=32"
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty" validate:"omitempty,max=32"`
	// Allow public key authentication (default: true)
	// @gotags: validate:"omitempty"
	AllowPubkey bool `protobuf:"varint,2,opt,name=allow_pubkey,json=allowPubkey,proto3" json:"allow_pubkey,omitempty" validate:"omitempty"`
	// Allow password authentication (default: false)
	// @gotags: validate:"omitempty"
	AllowPassword bool `protobuf:"varint,3,opt,name=allow_password,json=allowPassword,proto3" json:"allow_password,omitempty" validate:"omitempty"`
	// Users to add to the SSH access group (must be valid Linux usernames)
	// @gotags: validate:"omitempty,dive,min=1,max=32"
	Users         []string `protobuf:"bytes,6,rep,name=users,proto3" json:"users,omitempty" validate:"omitempty,dive,min=1,max=32"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SshParams) Reset() {
	*x = SshParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SshParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SshParams) ProtoMessage() {}

func (x *SshParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SshParams.ProtoReflect.Descriptor instead.
func (*SshParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{16}
}

func (x *SshParams) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *SshParams) GetAllowPubkey() bool {
	if x != nil {
		return x.AllowPubkey
	}
	return false
}

func (x *SshParams) GetAllowPassword() bool {
	if x != nil {
		return x.AllowPassword
	}
	return false
}

func (x *SshParams) GetUsers() []string {
	if x != nil {
		return x.Users
	}
	return nil
}

// SshdDirective represents a single sshd_config key-value directive.
type SshdDirective struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// sshd_config directive name (e.g., "PermitRootLogin", "Port")
	// @gotags: validate:"required,min=1,max=128"
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" validate:"required,min=1,max=128"`
	// Directive value (e.g., "no", "22")
	// @gotags: validate:"required,min=1,max=1024"
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" validate:"required,min=1,max=1024"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SshdDirective) Reset() {
	*x = SshdDirective{}
	mi := &file_pm_v1_actions_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SshdDirective) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SshdDirective) ProtoMessage() {}

func (x *SshdDirective) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SshdDirective.ProtoReflect.Descriptor instead.
func (*SshdDirective) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{17}
}

func (x *SshdDirective) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *SshdDirective) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// SshdParams configures the SSH daemon via sshd_config.d drop-in files.
// Each action creates a numbered config file for ordering (e.g., 0000-*.conf, 0001-*.conf).
// Priority is auto-assigned by the server based on creation order.
// The sshd service is automatically reloaded when configuration changes.
type SshdParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Priority for config file ordering (auto-assigned by server, lower = loaded first)
	// @gotags: validate:"omitempty"
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty" validate:"omitempty"`
	// sshd_config directives to set
	// @gotags: validate:"required,min=1,dive"
	Directives    []*SshdDirective `protobuf:"bytes,2,rep,name=directives,proto3" json:"directives,omitempty" validate:"required,min=1,dive"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SshdParams) Reset() {
	*x = SshdParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SshdParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SshdParams) ProtoMessage() {}

func (x *SshdParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SshdParams.ProtoReflect.Descriptor instead.
func (*SshdParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{18}
}

func (x *SshdParams) GetPriority() uint32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *SshdParams) GetDirectives() []*SshdDirective {
	if x != nil {
		return x.Directives
	}
	return nil
}

// SudoParams configures sudoers policies via /etc/sudoers.d/ drop-in files.
// Each action creates a Linux group pm-sudo-{actionId} and a corresponding
// sudoers file. Users specified in the users list are added to the group.
// When removed, the group and sudoers file are cleaned up.
type SudoParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Access level determines the sudo policy template
	// @gotags: validate:"required,ne=0"
	AccessLevel SudoAccessLevel `protobuf:"varint,1,opt,name=access_level,json=accessLevel,proto3,enum=pm.v1.SudoAccessLevel" json:"access_level,omitempty" validate:"required,ne=0"`
	// Users to add to the sudo group (must be valid Linux usernames)
	// @gotags: validate:"required,min=1,dive,min=1,max=32"
	Users []string `protobuf:"bytes,2,rep,name=users,proto3" json:"users,omitempty" validate:"required,min=1,dive,min=1,max=32"`
	// Custom sudoers rules (only used when access_level is CUSTOM)
	// Use {group} as placeholder for the auto-generated group name.
	// @gotags: validate:"omitempty,max=65536"
	CustomConfig  string `protobuf:"bytes,3,opt,name=custom_config,json=customConfig,proto3" json:"custom_config,omitempty" validate:"omitempty,max=65536"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SudoParams) Reset() {
	*x = SudoParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SudoParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SudoParams) ProtoMessage() {}

func (x *SudoParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SudoParams.ProtoReflect.Descriptor instead.
func (*SudoParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{19}
}

func (x *SudoParams) GetAccessLevel() SudoAccessLevel {
	if x != nil {
		return x.AccessLevel
	}
	return SudoAccessLevel_SUDO_ACCESS_LEVEL_UNSPECIFIED
}

func (x *SudoParams) GetUsers() []string {
	if x != nil {
		return x.Users
	}
	return nil
}

func (x *SudoParams) GetCustomConfig() string {
	if x != nil {
		return x.CustomConfig
	}
	return ""
}

// LpsParams configures Linux Password Solution (LAPS-like) password management.
// Each action targets one or more user accounts. The agent generates a random
// password for each user based on configured length/complexity, sets it via
// chpasswd, kills all user sessions, and reports the passwords back to the
// server. Rotation occurs independently per user on a schedule and optionally
// after authentication events.
type LpsParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target user accounts (must exist on device)
	// @gotags: validate:"required,min=1,dive,min=1,max=32"
	Usernames []string `protobuf:"bytes,1,rep,name=usernames,proto3" json:"usernames,omitempty" validate:"required,min=1,dive,min=1,max=32"`
	// Password length (8-128)
	// @gotags: validate:"required,gte=8,lte=128"
	PasswordLength int32 `protobuf:"varint,2,opt,name=password_length,json=passwordLength,proto3" json:"password_length,omitempty" validate:"required,gte=8,lte=128"`
	// Password complexity
	// @gotags: validate:"required,ne=0"
	Complexity LpsPasswordComplexity `protobuf:"varint,3,opt,name=complexity,proto3,enum=pm.v1.LpsPasswordComplexity" json:"complexity,omitempty" validate:"required,ne=0"`
	// Days between scheduled rotations (1-365)
	// @gotags: validate:"required,gte=1,lte=365"
	RotationIntervalDays int32 `protobuf:"varint,4,opt,name=rotation_interval_days,json=rotationIntervalDays,proto3" json:"rotation_interval_days,omitempty" validate:"required,gte=1,lte=365"`
	// Hours after auth event before automatic rotation (0 = disabled)
	// @gotags: validate:"omitempty,gte=0,lte=8760"
	GracePeriodHours int32 `protobuf:"varint,5,opt,name=grace_period_hours,json=gracePeriodHours,proto3" json:"grace_period_hours,omitempty" validate:"omitempty,gte=0,lte=8760"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *LpsParams) Reset() {
	*x = LpsParams{}
	mi := &file_pm_v1_actions_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LpsParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LpsParams) ProtoMessage() {}

func (x *LpsParams) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LpsParams.ProtoReflect.Descriptor instead.
func (*LpsParams) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{20}
}

func (x *LpsParams) GetUsernames() []string {
	if x != nil {
		return x.Usernames
	}
	return nil
}

func (x *LpsParams) GetPasswordLength() int32 {
	if x != nil {
		return x.PasswordLength
	}
	return 0
}

func (x *LpsParams) GetComplexity() LpsPasswordComplexity {
	if x != nil {
		return x.Complexity
	}
	return LpsPasswordComplexity_LPS_PASSWORD_COMPLEXITY_UNSPECIFIED
}

func (x *LpsParams) GetRotationIntervalDays() int32 {
	if x != nil {
		return x.RotationIntervalDays
	}
	return 0
}

func (x *LpsParams) GetGracePeriodHours() int32 {
	if x != nil {
		return x.GracePeriodHours
	}
	return 0
}

type ActionResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// @gotags: validate:"required"
	ActionId *ActionId `protobuf:"bytes,1,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty" validate:"required"`
	// @gotags: validate:"required"
	Status ExecutionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=pm.v1.ExecutionStatus" json:"status,omitempty" validate:"required"`
	// @gotags: validate:"omitempty,max=4096"
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty" validate:"omitempty,max=4096"`
	// @gotags: validate:"omitempty"
	Output *CommandOutput `protobuf:"bytes,4,opt,name=output,proto3" json:"output,omitempty" validate:"omitempty"`
	// @gotags: validate:"omitempty"
	CompletedAt *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty" validate:"omitempty"`
	// @gotags: validate:"omitempty,gte=0"
	DurationMs int64 `protobuf:"varint,6,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty" validate:"omitempty,gte=0"`
	// Whether the action made changes to the system (true) or state was already as desired (false)
	Changed bool `protobuf:"varint,7,opt,name=changed,proto3" json:"changed,omitempty"`
	// Optional action-specific metadata (e.g., LPS password data)
	// @gotags: validate:"omitempty"
	Metadata      map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value" validate:"omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ActionResult) Reset() {
	*x = ActionResult{}
	mi := &file_pm_v1_actions_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActionResult) ProtoMessage() {}

func (x *ActionResult) ProtoReflect() protoreflect.Message {
	mi := &file_pm_v1_actions_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActionResult.ProtoReflect.Descriptor instead.
func (*ActionResult) Descriptor() ([]byte, []int) {
	return file_pm_v1_actions_proto_rawDescGZIP(), []int{21}
}

func (x *ActionResult) GetActionId() *ActionId {
	if x != nil {
		return x.ActionId
	}
	return nil
}

func (x *ActionResult) GetStatus() ExecutionStatus {
	if x != nil {
		return x.Status
	}
	return ExecutionStatus_EXECUTION_STATUS_UNSPECIFIED
}

func (x *ActionResult) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ActionResult) GetOutput() *CommandOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *ActionResult) GetCompletedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CompletedAt
	}
	return nil
}

func (x *ActionResult) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *ActionResult) GetChanged() bool {
	if x != nil {
		return x.Changed
	}
	return false
}

func (x *ActionResult) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

var File_pm_v1_actions_proto protoreflect.FileDescriptor

const file_pm_v1_actions_proto_rawDesc = "" +
	"\n" +
	"\x13pm/v1/actions.proto\x12\x05pm.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x12pm/v1/common.proto\"\xba\a\n" +
	"\x06Action\x12\x1f\n" +
	"\x02id\x18\x01 \x01(\v2\x0f.pm.v1.ActionIdR\x02id\x12%\n" +
	"\x04type\x18\x02 \x01(\x0e2\x11.pm.v1.ActionTypeR\x04type\x128\n" +
	"\rdesired_state\x18\x03 \x01(\x0e2\x13.pm.v1.DesiredStateR\fdesiredState\x12'\n" +
	"\x0ftimeout_seconds\x18\x04 \x01(\x05R\x0etimeoutSeconds\x121\n" +
	"\bschedule\x18\x05 \x01(\v2\x15.pm.v1.ActionScheduleR\bschedule\x120\n" +
	"\apackage\x18\n" +
	" \x01(\v2\x14.pm.v1.PackageParamsH\x00R\apackage\x12+\n" +
	"\x03app\x18\v \x01(\v2\x17.pm.v1.AppInstallParamsH\x00R\x03app\x12*\n" +
	"\x05shell\x18\f \x01(\v2\x12.pm.v1.ShellParamsH\x00R\x05shell\x120\n" +
	"\asystemd\x18\r \x01(\v2\x14.pm.v1.SystemdParamsH\x00R\asystemd\x12'\n" +
	"\x04file\x18\x0e \x01(\v2\x11.pm.v1.FileParamsH\x00R\x04file\x12-\n" +
	"\x06update\x18\x0f \x01(\v2\x13.pm.v1.UpdateParamsH\x00R\x06update\x129\n" +
	"\n" +
	"repository\x18\x10 \x01(\v2\x17.pm.v1.RepositoryParamsH\x00R\n" +
	"repository\x120\n" +
	"\aflatpak\x18\x11 \x01(\v2\x14.pm.v1.FlatpakParamsH\x00R\aflatpak\x126\n" +
	"\tdirectory\x18\x12 \x01(\v2\x16.pm.v1.DirectoryParamsH\x00R\tdirectory\x12'\n" +
	"\x04user\x18\x13 \x01(\v2\x11.pm.v1.UserParamsH\x00R\x04user\x12$\n" +
	"\x03ssh\x18\x16 \x01(\v2\x10.pm.v1.SshParamsH\x00R\x03ssh\x12'\n" +
	"\x04sshd\x18\x17 \x01(\v2\x11.pm.v1.SshdParamsH\x00R\x04sshd\x12'\n" +
	"\x04sudo\x18\x18 \x01(\v2\x11.pm.v1.SudoParamsH\x00R\x04sudo\x12$\n" +
	"\x03lps\x18\x19 \x01(\v2\x10.pm.v1.LpsParamsH\x00R\x03lps\x12\x1c\n" +
	"\tsignature\x18\x14 \x01(\fR\tsignature\x12)\n" +
	"\x10params_canonical\x18\x15 \x01(\fR\x0fparamsCanonicalB\b\n" +
	"\x06params\"\x9b\x01\n" +
	"\x0eActionSchedule\x12\x12\n" +
	"\x04cron\x18\x01 \x01(\tR\x04cron\x12%\n" +
	"\x0einterval_hours\x18\x02 \x01(\x05R\rintervalHours\x12\"\n" +
	"\rrun_on_assign\x18\x03 \x01(\bR\vrunOnAssign\x12*\n" +
	"\x11skip_if_unchanged\x18\x04 \x01(\bR\x0fskipIfUnchanged\"\xf0\x01\n" +
	"\rPackageParams\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12'\n" +
	"\x0fallow_downgrade\x18\x03 \x01(\bR\x0eallowDowngrade\x12\x10\n" +
	"\x03pin\x18\x04 \x01(\bR\x03pin\x12\x19\n" +
	"\bapt_name\x18\n" +
	" \x01(\tR\aaptName\x12\x19\n" +
	"\bdnf_name\x18\v \x01(\tR\adnfName\x12\x1f\n" +
	"\vpacman_name\x18\f \x01(\tR\n" +
	"pacmanName\x12\x1f\n" +
	"\vzypper_name\x18\r \x01(\tR\n" +
	"zypperName\"p\n" +
	"\x10AppInstallParams\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12'\n" +
	"\x0fchecksum_sha256\x18\x02 \x01(\tR\x0echecksumSha256\x12!\n" +
	"\finstall_path\x18\x03 \x01(\tR\vinstallPath\"\x9b\x02\n" +
	"\vShellParams\x12\x16\n" +
	"\x06script\x18\x01 \x01(\tR\x06script\x12 \n" +
	"\vinterpreter\x18\x02 \x01(\tR\vinterpreter\x12\x1e\n" +
	"\vrun_as_root\x18\x03 \x01(\bR\trunAsRoot\x12+\n" +
	"\x11working_directory\x18\x04 \x01(\tR\x10workingDirectory\x12E\n" +
	"\venvironment\x18\x05 \x03(\v2#.pm.v1.ShellParams.EnvironmentEntryR\venvironment\x1a>\n" +
	"\x10EnvironmentEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa5\x01\n" +
	"\rSystemdParams\x12\x1b\n" +
	"\tunit_name\x18\x01 \x01(\tR\bunitName\x12<\n" +
	"\rdesired_state\x18\x02 \x01(\x0e2\x17.pm.v1.SystemdUnitStateR\fdesiredState\x12\x16\n" +
	"\x06enable\x18\x03 \x01(\bR\x06enable\x12!\n" +
	"\funit_content\x18\x04 \x01(\tR\vunitContent\"\x9f\x01\n" +
	"\n" +
	"FileParams\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x18\n" +
	"\acontent\x18\x02 \x01(\tR\acontent\x12\x14\n" +
	"\x05owner\x18\x03 \x01(\tR\x05owner\x12\x14\n" +
	"\x05group\x18\x04 \x01(\tR\x05group\x12\x12\n" +
	"\x04mode\x18\x05 \x01(\tR\x04mode\x12#\n" +
	"\rmanaged_block\x18\x06 \x01(\bR\fmanagedBlock\"\x83\x01\n" +
	"\x0fDirectoryParams\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x14\n" +
	"\x05owner\x18\x02 \x01(\tR\x05owner\x12\x14\n" +
	"\x05group\x18\x03 \x01(\tR\x05group\x12\x12\n" +
	"\x04mode\x18\x04 \x01(\tR\x04mode\x12\x1c\n" +
	"\trecursive\x18\x05 \x01(\bR\trecursive\"\x81\x01\n" +
	"\fUpdateParams\x12#\n" +
	"\rsecurity_only\x18\x01 \x01(\bR\fsecurityOnly\x12\x1e\n" +
	"\n" +
	"autoremove\x18\x02 \x01(\bR\n" +
	"autoremove\x12,\n" +
	"\x12reboot_if_required\x18\x03 \x01(\bR\x10rebootIfRequired\"q\n" +
	"\rFlatpakParams\x12\x15\n" +
	"\x06app_id\x18\x01 \x01(\tR\x05appId\x12\x16\n" +
	"\x06remote\x18\x02 \x01(\tR\x06remote\x12\x1f\n" +
	"\vsystem_wide\x18\x03 \x01(\bR\n" +
	"systemWide\x12\x10\n" +
	"\x03pin\x18\x04 \x01(\bR\x03pin\"\xd8\x01\n" +
	"\x10RepositoryParams\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12&\n" +
	"\x03apt\x18\n" +
	" \x01(\v2\x14.pm.v1.AptRepositoryR\x03apt\x12&\n" +
	"\x03dnf\x18\v \x01(\v2\x14.pm.v1.DnfRepositoryR\x03dnf\x12/\n" +
	"\x06pacman\x18\f \x01(\v2\x17.pm.v1.PacmanRepositoryR\x06pacman\x12/\n" +
	"\x06zypper\x18\r \x01(\v2\x17.pm.v1.ZypperRepositoryR\x06zypper\"\xe8\x01\n" +
	"\rAptRepository\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\"\n" +
	"\fdistribution\x18\x02 \x01(\tR\fdistribution\x12\x1e\n" +
	"\n" +
	"components\x18\x03 \x03(\tR\n" +
	"components\x12\x1e\n" +
	"\vgpg_key_url\x18\x04 \x01(\tR\tgpgKeyUrl\x12\x17\n" +
	"\agpg_key\x18\x05 \x01(\tR\x06gpgKey\x12\x18\n" +
	"\atrusted\x18\x06 \x01(\bR\atrusted\x12\x12\n" +
	"\x04arch\x18\a \x01(\tR\x04arch\x12\x1a\n" +
	"\bdisabled\x18\b \x01(\bR\bdisabled\"\xde\x01\n" +
	"\rDnfRepository\x12\x18\n" +
	"\abaseurl\x18\x01 \x01(\tR\abaseurl\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x18\n" +
	"\aenabled\x18\x03 \x01(\bR\aenabled\x12\x1a\n" +
	"\bgpgcheck\x18\x04 \x01(\bR\bgpgcheck\x12\x16\n" +
	"\x06gpgkey\x18\x05 \x01(\tR\x06gpgkey\x12'\n" +
	"\x0fmodule_hotfixes\x18\x06 \x01(\bR\x0emoduleHotfixes\x12\x1a\n" +
	"\bdisabled\x18\a \x01(\bR\bdisabled\"c\n" +
	"\x10PacmanRepository\x12\x16\n" +
	"\x06server\x18\x01 \x01(\tR\x06server\x12\x1b\n" +
	"\tsig_level\x18\x02 \x01(\tR\bsigLevel\x12\x1a\n" +
	"\bdisabled\x18\x03 \x01(\bR\bdisabled\"\xe6\x01\n" +
	"\x10ZypperRepository\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x18\n" +
	"\aenabled\x18\x03 \x01(\bR\aenabled\x12 \n" +
	"\vautorefresh\x18\x04 \x01(\bR\vautorefresh\x12\x1a\n" +
	"\bgpgcheck\x18\x05 \x01(\bR\bgpgcheck\x12\x16\n" +
	"\x06gpgkey\x18\x06 \x01(\tR\x06gpgkey\x12\x12\n" +
	"\x04type\x18\a \x01(\tR\x04type\x12\x1a\n" +
	"\bdisabled\x18\b \x01(\bR\bdisabled\"\xe2\x02\n" +
	"\n" +
	"UserParams\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x10\n" +
	"\x03uid\x18\x02 \x01(\x05R\x03uid\x12\x10\n" +
	"\x03gid\x18\x03 \x01(\x05R\x03gid\x12\x19\n" +
	"\bhome_dir\x18\x04 \x01(\tR\ahomeDir\x12\x14\n" +
	"\x05shell\x18\x05 \x01(\tR\x05shell\x12\x16\n" +
	"\x06groups\x18\x06 \x03(\tR\x06groups\x12.\n" +
	"\x13ssh_authorized_keys\x18\a \x03(\tR\x11sshAuthorizedKeys\x12\x18\n" +
	"\acomment\x18\b \x01(\tR\acomment\x12\x1f\n" +
	"\vsystem_user\x18\t \x01(\bR\n" +
	"systemUser\x12\x1f\n" +
	"\vcreate_home\x18\n" +
	" \x01(\bR\n" +
	"createHome\x12\x1a\n" +
	"\bdisabled\x18\v \x01(\bR\bdisabled\x12#\n" +
	"\rprimary_group\x18\f \x01(\tR\fprimaryGroup\"\xae\x01\n" +
	"\tSshParams\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12!\n" +
	"\fallow_pubkey\x18\x02 \x01(\bR\vallowPubkey\x12%\n" +
	"\x0eallow_password\x18\x03 \x01(\bR\rallowPassword\x12\x14\n" +
	"\x05users\x18\x06 \x03(\tR\x05usersJ\x04\b\x04\x10\x05J\x04\b\x05\x10\x06R\x0fauthorized_keysR\bhome_dir\"7\n" +
	"\rSshdDirective\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"^\n" +
	"\n" +
	"SshdParams\x12\x1a\n" +
	"\bpriority\x18\x01 \x01(\rR\bpriority\x124\n" +
	"\n" +
	"directives\x18\x02 \x03(\v2\x14.pm.v1.SshdDirectiveR\n" +
	"directives\"\x82\x01\n" +
	"\n" +
	"SudoParams\x129\n" +
	"\faccess_level\x18\x01 \x01(\x0e2\x16.pm.v1.SudoAccessLevelR\vaccessLevel\x12\x14\n" +
	"\x05users\x18\x02 \x03(\tR\x05users\x12#\n" +
	"\rcustom_config\x18\x03 \x01(\tR\fcustomConfig\"\xf4\x01\n" +
	"\tLpsParams\x12\x1c\n" +
	"\tusernames\x18\x01 \x03(\tR\tusernames\x12'\n" +
	"\x0fpassword_length\x18\x02 \x01(\x05R\x0epasswordLength\x12<\n" +
	"\n" +
	"complexity\x18\x03 \x01(\x0e2\x1c.pm.v1.LpsPasswordComplexityR\n" +
	"complexity\x124\n" +
	"\x16rotation_interval_days\x18\x04 \x01(\x05R\x14rotationIntervalDays\x12,\n" +
	"\x12grace_period_hours\x18\x05 \x01(\x05R\x10gracePeriodHours\"\xa6\x03\n" +
	"\fActionResult\x12,\n" +
	"\taction_id\x18\x01 \x01(\v2\x0f.pm.v1.ActionIdR\bactionId\x12.\n" +
	"\x06status\x18\x02 \x01(\x0e2\x16.pm.v1.ExecutionStatusR\x06status\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\x12,\n" +
	"\x06output\x18\x04 \x01(\v2\x14.pm.v1.CommandOutputR\x06output\x12=\n" +
	"\fcompleted_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\vcompletedAt\x12\x1f\n" +
	"\vduration_ms\x18\x06 \x01(\x03R\n" +
	"durationMs\x12\x18\n" +
	"\achanged\x18\a \x01(\bR\achanged\x12=\n" +
	"\bmetadata\x18\b \x03(\v2!.pm.v1.ActionResult.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*\xda\x03\n" +
	"\n" +
	"ActionType\x12\x1b\n" +
	"\x17ACTION_TYPE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13ACTION_TYPE_PACKAGE\x10\x01\x12\x16\n" +
	"\x12ACTION_TYPE_UPDATE\x10\x02\x12\x1a\n" +
	"\x16ACTION_TYPE_REPOSITORY\x10\x03\x12\x19\n" +
	"\x15ACTION_TYPE_APP_IMAGE\x10d\x12\x13\n" +
	"\x0fACTION_TYPE_DEB\x10e\x12\x13\n" +
	"\x0fACTION_TYPE_RPM\x10f\x12\x17\n" +
	"\x13ACTION_TYPE_FLATPAK\x10g\x12\x16\n" +
	"\x11ACTION_TYPE_SHELL\x10\xc8\x01\x12\x18\n" +
	"\x13ACTION_TYPE_SYSTEMD\x10\xac\x02\x12\x15\n" +
	"\x10ACTION_TYPE_FILE\x10\x90\x03\x12\x1a\n" +
	"\x15ACTION_TYPE_DIRECTORY\x10\x91\x03\x12\x17\n" +
	"\x12ACTION_TYPE_REBOOT\x10\xf4\x03\x12\x15\n" +
	"\x10ACTION_TYPE_SYNC\x10\xf5\x03\x12\x15\n" +
	"\x10ACTION_TYPE_USER\x10\xd8\x04\x12\x14\n" +
	"\x0fACTION_TYPE_SSH\x10\xbc\x05\x12\x15\n" +
	"\x10ACTION_TYPE_SSHD\x10\xbd\x05\x12\x15\n" +
	"\x10ACTION_TYPE_SUDO\x10\xa0\x06\x12\x14\n" +
	"\x0fACTION_TYPE_LPS\x10\x84\a*\x98\x01\n" +
	"\x10SystemdUnitState\x12\"\n" +
	"\x1eSYSTEMD_UNIT_STATE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aSYSTEMD_UNIT_STATE_STARTED\x10\x01\x12\x1e\n" +
	"\x1aSYSTEMD_UNIT_STATE_STOPPED\x10\x02\x12 \n" +
	"\x1cSYSTEMD_UNIT_STATE_RESTARTED\x10\x03*\x8d\x01\n" +
	"\x0fSudoAccessLevel\x12!\n" +
	"\x1dSUDO_ACCESS_LEVEL_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16SUDO_ACCESS_LEVEL_FULL\x10\x01\x12\x1d\n" +
	"\x19SUDO_ACCESS_LEVEL_LIMITED\x10\x02\x12\x1c\n" +
	"\x18SUDO_ACCESS_LEVEL_CUSTOM\x10\x03*\x8f\x01\n" +
	"\x15LpsPasswordComplexity\x12'\n" +
	"#LPS_PASSWORD_COMPLEXITY_UNSPECIFIED\x10\x00\x12(\n" +
	"$LPS_PASSWORD_COMPLEXITY_ALPHANUMERIC\x10\x01\x12#\n" +
	"\x1fLPS_PASSWORD_COMPLEXITY_COMPLEX\x10\x02B:Z8github.com/manchtools/power-manage/sdk/gen/go/pm/v1;pmv1b\x06proto3"

var (
	file_pm_v1_actions_proto_rawDescOnce sync.Once
	file_pm_v1_actions_proto_rawDescData []byte
)

func file_pm_v1_actions_proto_rawDescGZIP() []byte {
	file_pm_v1_actions_proto_rawDescOnce.Do(func() {
		file_pm_v1_actions_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pm_v1_actions_proto_rawDesc), len(file_pm_v1_actions_proto_rawDesc)))
	})
	return file_pm_v1_actions_proto_rawDescData
}

var file_pm_v1_actions_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_pm_v1_actions_proto_msgTypes = make([]protoimpl.MessageInfo, 24)
var file_pm_v1_actions_proto_goTypes = []any{
	(ActionType)(0),               // 0: pm.v1.ActionType
	(SystemdUnitState)(0),         // 1: pm.v1.SystemdUnitState
	(SudoAccessLevel)(0),          // 2: pm.v1.SudoAccessLevel
	(LpsPasswordComplexity)(0),    // 3: pm.v1.LpsPasswordComplexity
	(*Action)(nil),                // 4: pm.v1.Action
	(*ActionSchedule)(nil),        // 5: pm.v1.ActionSchedule
	(*PackageParams)(nil),         // 6: pm.v1.PackageParams
	(*AppInstallParams)(nil),      // 7: pm.v1.AppInstallParams
	(*ShellParams)(nil),           // 8: pm.v1.ShellParams
	(*SystemdParams)(nil),         // 9: pm.v1.SystemdParams
	(*FileParams)(nil),            // 10: pm.v1.FileParams
	(*DirectoryParams)(nil),       // 11: pm.v1.DirectoryParams
	(*UpdateParams)(nil),          // 12: pm.v1.UpdateParams
	(*FlatpakParams)(nil),         // 13: pm.v1.FlatpakParams
	(*RepositoryParams)(nil),      // 14: pm.v1.RepositoryParams
	(*AptRepository)(nil),         // 15: pm.v1.AptRepository
	(*DnfRepository)(nil),         // 16: pm.v1.DnfRepository
	(*PacmanRepository)(nil),      // 17: pm.v1.PacmanRepository
	(*ZypperRepository)(nil),      // 18: pm.v1.ZypperRepository
	(*UserParams)(nil),            // 19: pm.v1.UserParams
	(*SshParams)(nil),             // 20: pm.v1.SshParams
	(*SshdDirective)(nil),         // 21: pm.v1.SshdDirective
	(*SshdParams)(nil),            // 22: pm.v1.SshdParams
	(*SudoParams)(nil),            // 23: pm.v1.SudoParams
	(*LpsParams)(nil),             // 24: pm.v1.LpsParams
	(*ActionResult)(nil),          // 25: pm.v1.ActionResult
	nil,                           // 26: pm.v1.ShellParams.EnvironmentEntry
	nil,                           // 27: pm.v1.ActionResult.MetadataEntry
	(*ActionId)(nil),              // 28: pm.v1.ActionId
	(DesiredState)(0),             // 29: pm.v1.DesiredState
	(ExecutionStatus)(0),          // 30: pm.v1.ExecutionStatus
	(*CommandOutput)(nil),         // 31: pm.v1.CommandOutput
	(*timestamppb.Timestamp)(nil), // 32: google.protobuf.Timestamp
}
var file_pm_v1_actions_proto_depIdxs = []int32{
	28, // 0: pm.v1.Action.id:type_name -> pm.v1.ActionId
	0,  // 1: pm.v1.Action.type:type_name -> pm.v1.ActionType
	29, // 2: pm.v1.Action.desired_state:type_name -> pm.v1.DesiredState
	5,  // 3: pm.v1.Action.schedule:type_name -> pm.v1.ActionSchedule
	6,  // 4: pm.v1.Action.package:type_name -> pm.v1.PackageParams
	7,  // 5: pm.v1.Action.app:type_name -> pm.v1.AppInstallParams
	8,  // 6: pm.v1.Action.shell:type_name -> pm.v1.ShellParams
	9,  // 7: pm.v1.Action.systemd:type_name -> pm.v1.SystemdParams
	10, // 8: pm.v1.Action.file:type_name -> pm.v1.FileParams
	12, // 9: pm.v1.Action.update:type_name -> pm.v1.UpdateParams
	14, // 10: pm.v1.Action.repository:type_name -> pm.v1.RepositoryParams
	13, // 11: pm.v1.Action.flatpak:type_name -> pm.v1.FlatpakParams
	11, // 12: pm.v1.Action.directory:type_name -> pm.v1.DirectoryParams
	19, // 13: pm.v1.Action.user:type_name -> pm.v1.UserParams
	20, // 14: pm.v1.Action.ssh:type_name -> pm.v1.SshParams
	22, // 15: pm.v1.Action.sshd:type_name -> pm.v1.SshdParams
	23, // 16: pm.v1.Action.sudo:type_name -> pm.v1.SudoParams
	24, // 17: pm.v1.Action.lps:type_name -> pm.v1.LpsParams
	26, // 18: pm.v1.ShellParams.environment:type_name -> pm.v1.ShellParams.EnvironmentEntry
	1,  // 19: pm.v1.SystemdParams.desired_state:type_name -> pm.v1.SystemdUnitState
	15, // 20: pm.v1.RepositoryParams.apt:type_name -> pm.v1.AptRepository
	16, // 21: pm.v1.RepositoryParams.dnf:type_name -> pm.v1.DnfRepository
	17, // 22: pm.v1.RepositoryParams.pacman:type_name -> pm.v1.PacmanRepository
	18, // 23: pm.v1.RepositoryParams.zypper:type_name -> pm.v1.ZypperRepository
	21, // 24: pm.v1.SshdParams.directives:type_name -> pm.v1.SshdDirective
	2,  // 25: pm.v1.SudoParams.access_level:type_name -> pm.v1.SudoAccessLevel
	3,  // 26: pm.v1.LpsParams.complexity:type_name -> pm.v1.LpsPasswordComplexity
	28, // 27: pm.v1.ActionResult.action_id:type_name -> pm.v1.ActionId
	30, // 28: pm.v1.ActionResult.status:type_name -> pm.v1.ExecutionStatus
	31, // 29: pm.v1.ActionResult.output:type_name -> pm.v1.CommandOutput
	32, // 30: pm.v1.ActionResult.completed_at:type_name -> google.protobuf.Timestamp
	27, // 31: pm.v1.ActionResult.metadata:type_name -> pm.v1.ActionResult.MetadataEntry
	32, // [32:32] is the sub-list for method output_type
	32, // [32:32] is the sub-list for method input_type
	32, // [32:32] is the sub-list for extension type_name
	32, // [32:32] is the sub-list for extension extendee
	0,  // [0:32] is the sub-list for field type_name
}

func init() { file_pm_v1_actions_proto_init() }
func file_pm_v1_actions_proto_init() {
	if File_pm_v1_actions_proto != nil {
		return
	}
	file_pm_v1_common_proto_init()
	file_pm_v1_actions_proto_msgTypes[0].OneofWrappers = []any{
		(*Action_Package)(nil),
		(*Action_App)(nil),
		(*Action_Shell)(nil),
		(*Action_Systemd)(nil),
		(*Action_File)(nil),
		(*Action_Update)(nil),
		(*Action_Repository)(nil),
		(*Action_Flatpak)(nil),
		(*Action_Directory)(nil),
		(*Action_User)(nil),
		(*Action_Ssh)(nil),
		(*Action_Sshd)(nil),
		(*Action_Sudo)(nil),
		(*Action_Lps)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pm_v1_actions_proto_rawDesc), len(file_pm_v1_actions_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   24,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_pm_v1_actions_proto_goTypes,
		DependencyIndexes: file_pm_v1_actions_proto_depIdxs,
		EnumInfos:         file_pm_v1_actions_proto_enumTypes,
		MessageInfos:      file_pm_v1_actions_proto_msgTypes,
	}.Build()
	File_pm_v1_actions_proto = out.File
	file_pm_v1_actions_proto_goTypes = nil
	file_pm_v1_actions_proto_depIdxs = nil
}
